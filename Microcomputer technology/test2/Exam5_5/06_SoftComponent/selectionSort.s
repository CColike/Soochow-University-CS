//=======================================================================================
//文件名称：selectionSort.s
//功能概要：STM32L432RC 选择排序（汇编）程序文件
//版权所有：张昊
//版本更新：2022-05-01 V1.0
//=======================================================================================

//start 函数定义区域
.type selectionSort_down function               //声明为函数类型
.global selectionSort_down              	      //定义成全局函数，便于芯片初始化之后调用
.type selectionSort_up function               //声明为函数类型
.global selectionSort_up              	      //定义成全局函数，便于芯片初始化之后调用
//end  函数定义区域

//-----------------------以下为内部函数存放处---------------------------------
.section .text



//======================================================================
//函数名称：selectionSort_up
//参数说明：r0：存放数组的首地址 
//			r1：数组的长度 
//			r2：数组的长度r1-1，表示外层循环变量i/r3的最大值
//			r3：外层循环变量i 
//			r4：内层循环变量j 
//			r5：内层循环找到的待排序区间的最小元素的下标 
//			r6：临时变量，存放r0[r4]
//			r7：临时变量，存放r0[r5]
//功能概要：将r0所指向的数组，长度为r1，进行由小到大的选择排序
//======================================================================
selectionSort_up:
    push {r0-r7,lr}         //入栈保存数据现场
    //for(i=0;i<=r1-1;i++)  外层循环开始
    mov r3, #0			//r3：外层循环变量i ,初始值为0
    sub r2, r1, #1		//r2：数组的长度r1-1，表示外层循环变量i/r3的最大值
loop_up_outer:
    cmp r3, r2			    //比较r3/i是否达到了r2，
    bge loop_up_outer_done  //如果达到了，则排序完成，退出
    mov r5, r3			//r5：内层循环找到的待排序区间的最小元素的下标，初始值为r3/i
    //for(j=i+1;j<=r1;j++)  内层循环开始
    add r4, r3, #1		//r4：内层循环变量j 
loop_up_inner:
    cmp r4, r1			 //比较r4/j是否达到了r1，
    bge loop_up_inner_done //如果达到了，则已找到待排序区间里最小的元素，并将其下标存到了r5中
    ldrb r6, [r0, r4]	//r6：临时变量，存放r0[r4]
    ldrb r7, [r0, r5]	//r7：临时变量，存放r0[r5]
    cmp r6, r7
    bls loop_up_keep //若r6>=r7，即r0[r5]仍然是更小的元素，不修改
    mov r5, r4       //若r6< r7，即r0[r4]是更小的元素，修改最小元素的下标r5=r4
loop_up_keep:
    add r4, r4, #1		//r4/j++
    b loop_up_inner		
loop_up_inner_done:
    //r4/j->r1，已找到待排序区间里最小的元素，并将其下标存到了r5中
    //交换最小元素r0[r5]和待排序区首元素r0[r3]
    add r6, r0, r5	//r6=&r0[r5]
    add r7, r0, r3	//r7=&r0[r3]
    push {r0,r1}		//保护r0和r1
    mov r0, r6			//传递参数
    mov r1, r7
    bl swap				//调用交换函数
    pop {r0,r1}			//恢复数据
    add r3, r3, #1		//r3/i++
    b loop_up_outer		
loop_up_outer_done:
    //r3/i->r2，外层循环结束
    pop {r0-r7,pc}             //恢复数据现场

//======================================================================
//函数名称：swap
//参数说明：r0，r1:要交换的两个数据的地址
//功能概要：将r0,r1两个地址所指向的两个数据交换
//======================================================================
swap:
      push {r0-r7,lr}             //入栈保存数据现场
      //将r0与r1交换
      ldrb r2,[r0]				  //r2=*r0
      ldrb r3,[r1]				  //r3=*r1
      strb r2,[r1]				  //*r1=r2
      strb r3,[r0]			      //*r0=r3
      pop {r0-r7,pc}              //出栈恢复数据现场

//======================================================================
//函数名称：selectionSort_down
//函数返回：无
//参数说明：r0:用于存储数据的首地址，r1:数组的长度
//功能概要：将一数组采用选择排序的方式进行降序排列，且为原地排序
//======================================================================
//selectionSort_down:
//    push {r0-r7,lr}               //保存现场，pc(lr)入栈
//    //外层循环开始：每轮循环把待排序区的最大元素与待排序区的首元素交换
//    mov r2, #0			//r2=0 外层循环变量
//    sub r7, r1, #1		//循环终止于r7=r1-1
//down_loop_outer:
//    cmp r2, r7			//若r2>=r7，结束循环
//    bge down_loop_outer_after
//    //否则继续循环
//    mov r4, r2			//最大元素的下标r4=r2
//    //内层循环开始：找到最大的元素，下标存到r4
//    add r3, r2, #1		//r3=r2+1 内层循环变量
//down_loop_inner:
//    cmp r3, r1			//若r3>=r6，结束循环
//    bge down_loop_inner_after
//    //否则继续循环
//    ldrb r5, [r0, r3]	//r5=r0[r3]
//    ldrb r6, [r0, r4]	//r6=r0[r4]  (最大元素)
//    cmp r5, r6
//    //若r5<=r6，即r6=r0[r4]仍然是更大的元素，不修改
//    bls down_not_change	//修改这里！
//    //若r5>r6，即r5=r0[r3]是更大的元素，修改最大元素的下标r4=r3
//    mov r4, r3
//down_not_change:
//    add r3, r3, #1		//r3++
//    b down_loop_inner		//继续循环
//down_loop_inner_after:
//    //内层循环结束
//    //交换最大元素r0[r4]和待排序区首元素r0[r2]
//    add r5, r0, r4		//r5=&r0[r4]
//    add r6, r0, r2		//r6=&r0[r2]
//    push {r0,r1}		//保护r0和r1
//    mov r0, r5			//传递参数
//    mov r1, r6
//    bl swap				//调用交换函数
//    pop {r0,r1}			//恢复r0和r1
//    add r2, r2, #1		//r2++
//    b down_loop_outer		//继续循环
//down_loop_outer_after:
//    //外层循环结束
//    pop {r0-r7,pc}             //恢复现场，lr出栈到pc
//
